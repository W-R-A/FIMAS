#include "runRoutine.hpp"

//Create routine management thread
Thread routineManagerThread;

//Create Routine Thread
Thread routineThread(osPriorityRealtime);

//Create eventqueue to be run on routineThread
EventQueue routineQueue;

//Seconds since starting routine
uint16_t routineElapsed;

//Routine duration in seconds
uint16_t routineDuration;

//ID of the EventQueue task generated by calling runRoutine every second
int routineEventQueueID = 0;


//RoutineThreadFunction - Responsible for running the routine EventQueue
void routineThreadFunction(void) {

    //Start event queue on thread
    routineQueue.dispatch();
}

//Manage the running of routines based on the state of the system 
//No parameters need to be passed and nothing is returned
void routineManager(void) {

    //Enter an infinite loop managing the routine running
    while (true) {

        //Wait while the system is not in the running state
        if (_dataManager.getSystemState() == STATE_RUNNING_START) {

            //Reset the time elapsed to zero
            routineElapsed = 0;

            //Set the routine duration
            routineDuration = _dataManager.getRoutineDuration();

            //Run the routine
            routineEventQueueID = routineQueue.call_every(1s, runRoutine);

            //Update the system state
            _dataManager.setSystemState(STATE_RUNNING);
        }

        //If the system status changes to ESTOP or ERROR state, stop the routine, and return to IDLE state
        if ((_dataManager.getSystemState() == STATE_ERROR) || (_dataManager.getSystemState() == STATE_ESTOP)) {

            //Stop the routine
            routineQueue.cancel(routineEventQueueID);

            //Reset devies to default state
            _dataManager.setResetRoutineDevices();

            //Update the system state
            _dataManager.setSystemState(STATE_IDLE);
        }

        //Sleep for 200ms
        ThisThread::sleep_for(200);
    }
}


void runRoutine(void) {

    //If the routine has not finished
    if (routineElapsed < routineDuration) {
        
        //Loop through routine and change state if required
        for (int i = 0; i < _dataManager.getRoutineSize(); i++) {

            //Get timing block
            deviceTimes timing = _dataManager.getRoutineTimingBlock(i);

            //If a device needs to change state
            if (routineElapsed == timing.startTime) {

                //Change the state of the device
                _dataManager.setDeviceState(timing.devID, timing.devState);
            }
        }

        //Increment elapsed time
        routineElapsed++;

    }
    else {
        //Stop the function from being called again as the routine has finished
        routineQueue.cancel(routineEventQueueID);

        //Reset devies to default state
        _dataManager.setResetRoutineDevices();

        //Set the system back to IDLE state
        _dataManager.setSystemState(STATE_IDLE);
    }
}

